#!/usr/bin/env python3
"""
Build Atlas Script for WorldGenerator
Combines all 48 tiles from RawTileArt/ into a single atlas.png
and generates tile_data.js with UV coordinates for WebGL sampling.

Also embeds the atlas as base64 for file:// protocol compatibility.
"""

import os
import math
import base64
from io import BytesIO
from PIL import Image

# Configuration
TILE_SIZE = 16
RAW_TILE_DIR = "../RawTileArt"
OUTPUT_ATLAS = "../assets/tiles/atlas.png"
OUTPUT_JS = "../assets/tile_atlas_data.js"

def get_tile_files(raw_dir):
    """Get all PNG tile files from the raw directory."""
    tiles = []
    for filename in sorted(os.listdir(raw_dir)):
        if filename.endswith('.png'):
            # Extract tile name from filename like "16x16 Tiles-Brick.png"
            name = filename.replace('16x16 Tiles-', '').replace('.png', '')
            # Convert to JS-friendly identifier
            js_name = name.replace(' ', '_').replace('(', '').replace(')', '').replace('-', '_')
            tiles.append({
                'filename': filename,
                'name': name,
                'js_name': js_name,
                'path': os.path.join(raw_dir, filename)
            })
    return tiles

def calculate_atlas_dimensions(num_tiles, tile_size):
    """Calculate optimal atlas dimensions (power of 2 preferred for WebGL)."""
    # Find smallest square that fits all tiles
    tiles_per_side = math.ceil(math.sqrt(num_tiles))
    # Round up to power of 2 for WebGL efficiency
    atlas_tiles = 1
    while atlas_tiles < tiles_per_side:
        atlas_tiles *= 2
    return atlas_tiles * tile_size, atlas_tiles

def build_atlas(tiles, tile_size, output_path):
    """Build the texture atlas from individual tile images."""
    num_tiles = len(tiles)
    atlas_size, tiles_per_side = calculate_atlas_dimensions(num_tiles, tile_size)
    
    print(f"Building atlas: {atlas_size}x{atlas_size} ({tiles_per_side}x{tiles_per_side} tiles)")
    
    # Create atlas image with transparency
    atlas = Image.new('RGBA', (atlas_size, atlas_size), (0, 0, 0, 0))
    
    # Place each tile
    tile_positions = {}
    for i, tile in enumerate(tiles):
        row = i // tiles_per_side
        col = i % tiles_per_side
        x = col * tile_size
        y = row * tile_size
        
        # Load tile image
        try:
            tile_img = Image.open(tile['path'])
            # Ensure it's RGBA
            if tile_img.mode != 'RGBA':
                tile_img = tile_img.convert('RGBA')
            # Resize if needed (shouldn't be, but just in case)
            if tile_img.size != (tile_size, tile_size):
                print(f"  Warning: {tile['name']} is {tile_img.size}, resizing to {tile_size}x{tile_size}")
                tile_img = tile_img.resize((tile_size, tile_size), Image.Resampling.NEAREST)
            # Paste into atlas
            atlas.paste(tile_img, (x, y))
            tile_positions[tile['js_name']] = {
                'index': i,
                'x': x,
                'y': y,
                'row': row,
                'col': col
            }
            print(f"  [{i:2d}] {tile['name']} -> ({col}, {row})")
        except Exception as e:
            print(f"  ERROR loading {tile['name']}: {e}")
            raise
    
    # Save atlas
    atlas.save(output_path, 'PNG')
    print(f"\nAtlas saved to: {output_path}")
    
    # Generate base64 data URL for file:// protocol compatibility
    buffer = BytesIO()
    atlas.save(buffer, format='PNG')
    base64_data = base64.b64encode(buffer.getvalue()).decode('utf-8')
    data_url = f"data:image/png;base64,{base64_data}"
    print(f"Base64 data URL generated ({len(base64_data)} bytes)")
    
    return tile_positions, atlas_size, tiles_per_side, data_url

def generate_js(tiles, positions, atlas_size, tiles_per_side, tile_size, output_path, data_url):
    """Generate the JavaScript tile data file."""
    
    # Calculate UV coordinates (0-1 range for WebGL)
    uv_tile_size = tile_size / atlas_size
    
    js_content = f"""// AIDEV-NOTE: Auto-generated by build_atlas.py - DO NOT EDIT MANUALLY
// Tile atlas data for WebGL rendering
// Atlas size: {atlas_size}x{atlas_size} ({tiles_per_side}x{tiles_per_side} tiles)
// Tile size: {tile_size}x{tile_size} pixels

const TileAtlas = {{
    // Atlas dimensions
    ATLAS_SIZE: {atlas_size},
    TILES_PER_SIDE: {tiles_per_side},
    TILE_SIZE: {tile_size},
    UV_TILE_SIZE: {uv_tile_size},
    
    // Base64 embedded atlas for file:// protocol compatibility
    // AIDEV-NOTE: This allows the game to work when opened directly from file system
    ATLAS_DATA_URL: "{data_url}",
    
    // Tile indices (for quick lookup)
    Tiles: {{
"""
    
    # Add tile enum
    for tile in tiles:
        pos = positions[tile['js_name']]
        js_content += f"        {tile['js_name']}: {pos['index']},\n"
    
    js_content += """    },
    
    // Tile metadata (names, categories)
    TileData: [
"""
    
    # Add tile data array
    for tile in tiles:
        pos = positions[tile['js_name']]
        # Determine category based on name
        name = tile['name']
        if name.startswith('Far BG'):
            category = 'FAR_BG'
        elif name.startswith('BG'):
            category = 'BG'
        elif any(x in name for x in ['Switch', 'Button', 'Power Block', 'Mechanical', 'Electric']):
            category = 'MECHANICAL'
        elif any(x in name for x in ['Dirt', 'Sand', 'Meteor', 'Cloud', 'Slime']):
            category = 'TERRAIN'
        elif any(x in name for x in ['Glass', 'Thorns', 'Smile', 'Melon', 'Piano', 'Puzzle', 'Black']):
            category = 'SPECIAL'
        else:
            category = 'DUNGEON'
        
        js_content += f'        {{ name: "{tile["name"]}", category: "{category}", col: {pos["col"]}, row: {pos["row"]} }},\n'
    
    js_content += """    ],
    
    // Get UV coordinates for a tile index
    // Returns { u, v, uSize, vSize } for WebGL texture sampling
    // AIDEV-NOTE: Half-pixel inset prevents sampling adjacent tiles at boundaries
    getUV(tileIndex) {
        const col = tileIndex % this.TILES_PER_SIDE;
        const row = Math.floor(tileIndex / this.TILES_PER_SIDE);
        
        // Half-pixel inset to prevent texture bleeding (0.5 / atlas_size)
        const halfPixel = 0.5 / this.ATLAS_SIZE;
        
        return {
            u: col * this.UV_TILE_SIZE + halfPixel,
            v: row * this.UV_TILE_SIZE + halfPixel,
            uSize: this.UV_TILE_SIZE - halfPixel * 2,
            vSize: this.UV_TILE_SIZE - halfPixel * 2
        };
    },
    
    // Get tile index by name
    getTileIndex(name) {
        return this.Tiles[name] ?? -1;
    },
    
    // Get tiles by category
    getTilesByCategory(category) {
        return this.TileData
            .map((tile, index) => ({ ...tile, index }))
            .filter(tile => tile.category === category);
    }
};
"""
    
    with open(output_path, 'w') as f:
        f.write(js_content)
    
    print(f"JavaScript saved to: {output_path}")

def main():
    # Change to script directory for relative paths
    script_dir = os.path.dirname(os.path.abspath(__file__))
    os.chdir(script_dir)
    
    print("=== WorldGenerator Tile Atlas Builder ===\n")
    
    # Get all tile files
    tiles = get_tile_files(RAW_TILE_DIR)
    print(f"Found {len(tiles)} tiles\n")
    
    if len(tiles) == 0:
        print("ERROR: No tiles found!")
        return 1
    
    # Build atlas
    positions, atlas_size, tiles_per_side, data_url = build_atlas(tiles, TILE_SIZE, OUTPUT_ATLAS)
    
    # Generate JavaScript with embedded base64 atlas
    generate_js(tiles, positions, atlas_size, tiles_per_side, TILE_SIZE, OUTPUT_JS, data_url)
    
    print(f"\n=== Done! {len(tiles)} tiles packed into atlas ===")
    return 0

if __name__ == "__main__":
    exit(main())

